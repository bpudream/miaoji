既然你决定**新建表**，这是一个非常英明的决策。在开发阶段甩掉“历史包袱”，采用最符合业务逻辑的数据结构，能让后续的“流式转写”和“实时翻译”开发变得极其顺畅。

采用**分段存储（Segment-based Storage）**是行业标准做法。

以下是基于新表结构的完整设计方案，包含数据库设计、流式处理逻辑以及前后端交互。

---

# 架构重构：基于 Segment 的流式处理方案

## 1. 核心变更理念

* **弃用**：不再把大段 JSON 存进一个 `TEXT` 字段。
* **采用**：原子化存储。每一句字幕（Segment）都是数据库里的一行记录。
* **优势**：
* **写入快**：流式转写时，来一句插一句，不用读写整个大 JSON。
* **实时翻译**：翻译服务可以像“流水线工人”一样，盯着转写表，出来几句就抓走翻译几句，然后写回翻译表。
* **并发安全**：转写和翻译操作不同的行或表，完全解耦，互不干扰。



---

## 2. 数据库设计 (Schema Design)

我们需要两个核心的新表，配合原有的主表（作为元数据头）。

### 2.1 调整 `transcriptions` 表 (保留作为 Header)

只存元数据，不再存 `content`。

```sql
CREATE TABLE IF NOT EXISTS transcriptions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  media_file_id TEXT NOT NULL,
  status TEXT DEFAULT 'pending', -- pending, processing, completed, error
  model_config TEXT,             -- 记录使用的模型、prompt等
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (media_file_id) REFERENCES media_files(id)
);

```

### 2.2 新建 `transcription_segments` 表 (原子化转写)

这是流式转写的写入目标。

```sql
CREATE TABLE IF NOT EXISTS transcription_segments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transcription_id INTEGER NOT NULL,
  segment_index INTEGER NOT NULL,  -- 关键：段落序号 (0, 1, 2...)
  start_time REAL NOT NULL,        -- 开始时间 (秒)
  end_time REAL NOT NULL,          -- 结束时间 (秒)
  text TEXT NOT NULL,              -- 原文内容
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (transcription_id) REFERENCES transcriptions(id),
  UNIQUE(transcription_id, segment_index) -- 保证序号唯一
);
-- 索引建议：按 transcription_id 查询
CREATE INDEX idx_trans_segments_tid ON transcription_segments(transcription_id);

```

### 2.3 新建 `translation_segments` 表 (原子化翻译)

这是流式翻译的写入目标。

```sql
CREATE TABLE IF NOT EXISTS translation_segments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  transcription_id INTEGER NOT NULL, -- 关联回转写ID
  language TEXT NOT NULL,            -- 目标语言 (如 'zh')
  segment_index INTEGER NOT NULL,    -- 对应原文的序号 (1:1映射)
  text TEXT NOT NULL,                -- 译文内容
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (transcription_id) REFERENCES transcriptions(id),
  UNIQUE(transcription_id, language, segment_index)
);
-- 索引建议
CREATE INDEX idx_trans_l_segments ON translation_segments(transcription_id, language);

```

---

## 3. 后端逻辑重构 (Node.js)

### 3.1 阶段一：流式转写 (Producer)

在 `Queue.ts` 和 `Python Worker` 交互时：

1. **Worker 输出**：`{"index": 0, "start": 0.0, "end": 2.0, "text": "Hello"}`
2. **Node 监听**：
* 收到一行 JSON。
* 执行 `INSERT INTO transcription_segments (transcription_id, segment_index, ...) VALUES (...)`。
* **触发事件**：`eventBus.emit('segment_created', { transcriptionId, index, text })`。



### 3.2 阶段二：自动流式翻译 (Consumer)

我们需要一个 `TranslationScheduler`（或在 `TranslationService` 中监听事件）。

**逻辑策略：批处理 (Batching)**
不要来一句翻一句（浪费 Token 且无上下文）。要“攒一波”。

1. **监听/轮询**：
* 检查 `transcription_segments` 中最新的 `segment_index` (比如到了 50)。
* 检查 `translation_segments` (language='zh') 中最新的 `segment_index` (比如只到 40)。
* **差距**：10 句未翻译。


2. **触发翻译**：
* 如果差距 >= 5 (Batch Size)，或者转写已标记 `completed`。
* `SELECT * FROM transcription_segments WHERE index > 40 AND index <= 50`。
* 构造 Prompt 发送给 LLM (DeepSeek)。


3. **写入译文**：
* 收到 LLM 返回的 10 句译文。
* 批量 `INSERT INTO translation_segments`。



---

## 4. API 与 前端交互变更

由于数据变了，接口也需要调整，变得更简单直观。

### 4.1 统一获取接口

前端轮询这一个接口即可同时拿到原文和译文（如果已生成）。

* **GET** `/api/projects/:id/transcription/segments?language=zh`

**SQL 逻辑 (Left Join)**：

```sql
SELECT
  ts.segment_index,
  ts.start_time,
  ts.end_time,
  ts.text as original_text,
  tls.text as translated_text
FROM transcription_segments ts
LEFT JOIN translation_segments tls
  ON ts.transcription_id = tls.transcription_id
  AND ts.segment_index = tls.segment_index
  AND tls.language = 'zh'
WHERE ts.transcription_id = ?
ORDER BY ts.segment_index ASC;

```

**返回结构**：

```json
[
  {
    "index": 0,
    "start": 0.0,
    "end": 2.5,
    "original": "Welcome to the match.",
    "translation": "欢迎来到比赛现场。"  // 如果还没翻完，这里是 null
  },
  {
    "index": 1,
    "start": 2.5,
    "end": 5.0,
    "original": "Kick off!",
    "translation": null // 前端显示转圈或留空
  }
]

```

### 4.2 前端渲染

* **双语对照组件**：直接遍历这个数组。
* **实时更新**：前端每 3 秒轮询一次。
* 如果 `original` 增加了 -> 渲染新行。
* 如果 `translation` 从 `null` 变有值了 -> 渲染译文。


* **无需复杂合并**：后端 SQL 的 `LEFT JOIN` 已经帮你把原文和译文对齐了，前端代码会极度简洁。

---

## 5. 总结

改用**新表结构 (Segments)** 是你目前的最优解：

1. **开发更爽**：逻辑清晰，不用处理复杂的 JSON 解析和追加。
2. **性能更好**：数据库层面的读写分离和原子操作。
3. **体验更强**：完美支持“这边在转写，那边已经在出翻译”的流水线效果。
